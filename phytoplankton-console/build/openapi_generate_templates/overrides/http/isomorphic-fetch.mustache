import {HttpLibrary, RequestContext, ResponseContext} from './http{{extensionForDeno}}';
import { from, Observable } from {{#useRxJS}}'rxjs'{{/useRxJS}}{{^useRxJS}}'../rxjsStub{{extensionForDeno}}'{{/useRxJS}};
{{#platforms}}
{{#node}}
import fetch from "node-fetch";
{{/node}}
{{#browser}}
import "whatwg-fetch";
{{/browser}}
{{/platforms}}


export class FetchCallError extends Error {
  public constructor(
    message: string,
    public request: {
      url: string;
      method: string;
      body: unknown,
      headers: unknown,
    },
  ) {
    super(message);
    this.name = "FetchCallError"
  }
}

export class IsomorphicFetchHttpLibrary implements HttpLibrary {

    public send(request: RequestContext): Observable<ResponseContext> {
        let method = request.getHttpMethod().toString();
        let body = request.getBody();

        const url = request.getUrl();
       const headers = request.getHeaders();

        const resultPromise = fetch(url, {
            method: method,
            body: body as any,
            headers: headers,
            {{#platforms}}
            {{#node}}
            agent: request.getAgent(),
            {{/node}}
            {{#browser}}
            credentials: "same-origin"
            {{/browser}}
            {{/platforms}}
        }).then((resp: any) => {
            const headers: { [name: string]: string } = {};
            resp.headers.forEach((value: string, name: string) => {
              headers[name] = value;
            });

            {{#platforms}}
            {{#node}}
            const body = {
              text: () => resp.text(),
              binary: () => resp.buffer()
            };
            {{/node}}
            {{^node}}
            const body = {
              text: () => resp.text(),
              binary: () => resp.blob()
            };
            {{/node}}
            {{/platforms}}
            return new ResponseContext(resp.status, headers, body);
        }, (e) => {
          // If fetch failed on network level, create custom error with details
          if (e instanceof TypeError && e.message === 'Failed to fetch') {
            throw new FetchCallError(`HTTP fetch failed (${method} ${url})`, {
              url,
              method,
              body,
              headers,
            });
          }
          throw e;
       });

        return from<Promise<ResponseContext>>(resultPromise);

    }
}

import fs from 'fs'
import { Config } from '@flagright/lib/config/config'
import { StackConstants, getResourceName, getSuffix } from '@lib/constants'
import { RemovalPolicy } from 'aws-cdk-lib'
import {
  ApiDefinition,
  AssetApiDefinition,
  EndpointType,
  LogGroupLogDestination,
  MethodLoggingLevel,
  ResponseType,
  SpecRestApi,
} from 'aws-cdk-lib/aws-apigateway'
import { LogGroup } from 'aws-cdk-lib/aws-logs'
import { Asset } from 'aws-cdk-lib/aws-s3-assets'
import { Construct } from 'constructs'
import { LAMBDAS } from '@lib/lambdas'
import { isQaEnv } from '@flagright/lib/qa'
import { random, range } from 'lodash'

const isDevUserStack = isQaEnv()

const MockDefinition = {
  openapi: '3.0.2',
  paths: {
    '/pets': {
      get: {
        responses: {
          200: {
            content: {
              'application/json': {
                schema: { $ref: '#/components/schemas/Empty' },
              },
            },
          },
        },
        'x-amazon-apigateway-integration': {
          responses: { default: { statusCode: '200' } },
          requestTemplates: { 'application/json': '{"statusCode": 200}' },
          passthroughBehavior: 'when_no_match',
          type: 'mock',
        },
      },
    },
  },
  components: { schemas: { Empty: { title: 'Empty Schema', type: 'object' } } },
}

export function createApiGateway(
  context: Construct & { config: Config },
  apiName: string
): {
  api: SpecRestApi
  logGroup: LogGroup
} {
  // Log group ID cannot be changed
  let logGroupId: string
  let openapiName: 'public' | 'public-management' | 'internal'
  if (apiName === StackConstants.TARPON_API_NAME) {
    openapiName = 'public'
    logGroupId = 'LogGroupPublicApi'
  } else if (apiName === StackConstants.TARPON_MANAGEMENT_API_NAME) {
    openapiName = 'public-management'
    logGroupId = 'LogGroupPublicManagementApi'
  } else if (apiName === StackConstants.CONSOLE_API_NAME) {
    openapiName = 'internal'

    // TODO: Remove this in the next PR
    apiName += 'New'
    logGroupId = 'LogGroupConsoleApiNew'
  } else {
    throw new Error(`Cannot find openapi for ${apiName}`)
  }

  const OPENAPI_PATH = `./dist/openapi/openapi-${openapiName}-autogenerated-${context.config.stage}.yaml`

  const preprocess = () => {
    let spec = fs
      .readFileSync(OPENAPI_PATH, 'utf8')
      .replace(/{{region}}/g, context.config.env.region as string)
      .replace(/{{accountId}}/g, context.config.env.account as string)

    Object.keys(LAMBDAS).forEach((lambdaKey) => {
      const lambdaName = lambdaKey.replace(getSuffix(), '')
      const re1 = new RegExp(`{{${lambdaName}}}`, 'g')
      spec = spec.replace(re1, lambdaKey)
      const re2 = new RegExp(`{{${lambdaKey}}}`, 'g')
      spec = spec.replace(re2, lambdaKey)
    })

    fs.writeFileSync(OPENAPI_PATH, spec)
  }

  let apiDefinition: ApiDefinition
  if (process.env.INFRA_CI === 'true') {
    apiDefinition = ApiDefinition.fromInline(MockDefinition)
  } else if (context.config.stage === 'local') {
    preprocess()
    apiDefinition = ApiDefinition.fromInline(OPENAPI_PATH)
  } else {
    preprocess()
    const openApiAsset = new Asset(context, `${openapiName}-openapi-asset`, {
      path: OPENAPI_PATH,
    })
    apiDefinition = AssetApiDefinition.fromBucket(
      openApiAsset.bucket,
      openApiAsset.s3ObjectKey
    )
  }
  const logGroupName = getResourceName(`API-Gateway-Execution-Logs_${apiName}`)
  const apiLogGroup = new LogGroup(context, logGroupId, {
    logGroupName,
    retention: context.config.resource.CLOUD_WATCH.logRetention,
    removalPolicy:
      context.config.stage === 'dev'
        ? RemovalPolicy.DESTROY
        : RemovalPolicy.RETAIN,
  })

  const restApi = new SpecRestApi(context, apiName, {
    endpointTypes: isDevUserStack
      ? [EndpointType.REGIONAL]
      : [EndpointType.EDGE],
    restApiName: apiName,
    apiDefinition,
    deploy: true,
    deployOptions: {
      loggingLevel: MethodLoggingLevel.INFO,
      tracingEnabled: true,
      metricsEnabled: true,
      accessLogDestination: new LogGroupLogDestination(apiLogGroup),
    },
  })

  // NOTE: We add random spaces to the end of the validation response template (which won't affect the response) to make
  // the template get updated for every deployment (0.1% chance of conflict) to get around the template being reset for
  // unknown reasons.
  const randomSpacesSuffix = range(random(1, 1000))
    .map(() => '')
    .join(' ')
  const apiValidationErrorTemplate = {
    'application/json':
      '{ "message": $context.error.messageString, "validationErrors": "$context.error.validationErrorString" }' +
      randomSpacesSuffix,
  }
  restApi.addGatewayResponse('BadRequestBodyValidationResponse', {
    type: ResponseType.BAD_REQUEST_BODY,
    statusCode: '400',
    templates: apiValidationErrorTemplate,
  })
  restApi.addGatewayResponse('BadRequestParametersValidationResponse', {
    type: ResponseType.BAD_REQUEST_PARAMETERS,
    statusCode: '400',
    templates: apiValidationErrorTemplate,
  })
  return {
    api: restApi,
    logGroup: apiLogGroup,
  }
}

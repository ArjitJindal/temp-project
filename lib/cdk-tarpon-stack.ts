import * as cdk from '@aws-cdk/core'
import {
  ArnPrincipal,
  Effect,
  ManagedPolicy,
  Policy,
  PolicyStatement,
  Role,
} from '@aws-cdk/aws-iam'
import { AttributeType, Table } from '@aws-cdk/aws-dynamodb'

import {
  AuthorizationType,
  IdentitySource,
  LambdaIntegration,
  LambdaRestApi,
  RequestAuthorizer,
} from '@aws-cdk/aws-apigateway'

import { CfnOutput, Duration } from '@aws-cdk/core'

import { Code, Function, Runtime, Tracing } from '@aws-cdk/aws-lambda'
import { TarponStackConstants } from './constants'

export class CdkTarponStack extends cdk.Stack {
  constructor(scope: cdk.Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props)

    /**
     * DynamoDB
     */
    const dynamoDbTable = new Table(this, 'Tarpon', {
      tableName: TarponStackConstants.DYNAMODB_TABLE_NAME,
      partitionKey: { name: 'PartitionKeyID', type: AttributeType.STRING },
      sortKey: { name: 'SortKeyID', type: AttributeType.STRING },
      readCapacity: 1,
      writeCapacity: 1,
    })

    /**
     * Lambda Functions
     */
    const apiKeyGeneratorFunction = new Function(
      this,
      'ApiKeyGeneratorFunction',
      {
        functionName: 'ApiKeyGeneratorFunction',
        runtime: Runtime.NODEJS_14_X,
        handler: 'app.apiKeyGeneratorHandler',
        code: Code.fromAsset('dist/api-key-generator'),
        tracing: Tracing.ACTIVE,
        timeout: Duration.seconds(10),
      }
    )
    apiKeyGeneratorFunction.role?.attachInlinePolicy(
      new Policy(this, 'ApiKeyGeneratorPolicy', {
        statements: [
          new PolicyStatement({
            effect: Effect.ALLOW,
            actions: ['apigateway:POST'],
            resources: [
              'arn:aws:apigateway:*::/apikeys',
              'arn:aws:apigateway:*::/usageplans/*/keys',
            ],
          }),
        ],
      })
    )

    const apiKeyAuthorizerFunction = new Function(
      this,
      'ApiKeyAuthorizerFunction',
      {
        functionName: 'ApiKeyAuthorizerFunction',
        runtime: Runtime.NODEJS_14_X,
        handler: 'app.apiKeyHandler',
        code: Code.fromAsset('dist/authorizer'),
        tracing: Tracing.ACTIVE,
        timeout: Duration.seconds(10),
      }
    )

    const verifyTransactionFunction = new Function(
      this,
      'VerifyTransactionFunction',
      {
        functionName: 'VerifyTransactionFunction',
        runtime: Runtime.NODEJS_14_X,
        handler: 'app.verifyTransactionHandler',
        code: Code.fromAsset('dist/rules-engine'),
        tracing: Tracing.ACTIVE,
        timeout: Duration.seconds(10),
      }
    )
    dynamoDbTable.grantReadWriteData(verifyTransactionFunction)

    const ruleInstanceFunction = new Function(this, 'RuleInstanceFunction', {
      functionName: 'RuleInstanceFunction',
      runtime: Runtime.NODEJS_14_X,
      handler: 'app.ruleInstanceHandler',
      code: Code.fromAsset('dist/rules-engine'),
      tracing: Tracing.ACTIVE,
      timeout: Duration.seconds(10),
    })
    dynamoDbTable.grantReadWriteData(ruleInstanceFunction)

    /**
     * API Gateway
     */

    // TODO: CDK+OpenAPI integration (issue: https://github.com/aws/aws-cdk/issues/1461)
    const api = new LambdaRestApi(this, 'TarponAPI', {
      handler: verifyTransactionFunction, // TODO: create default handler,
      proxy: false,
    })
    const apiKeyAuthorizer = new RequestAuthorizer(this, 'TarponAuthorizer', {
      handler: apiKeyAuthorizerFunction,
      identitySources: [IdentitySource.header('x-api-key')],
      resultsCacheTtl: Duration.seconds(0),
    })
    const transactions = api.root.addResource('transaction')
    transactions.addMethod(
      'POST',
      new LambdaIntegration(verifyTransactionFunction, { proxy: true }),
      {
        authorizationType: AuthorizationType.CUSTOM,
        authorizer: apiKeyAuthorizer,
        apiKeyRequired: true,
      }
    )

    // NOTE: API Key is currently generated by us and delivered to customers manually.
    // This endpoint will be used by Flagright console UI and customers can generate
    // the API keys by themselves.
    const apiKey = api.root.addResource('apikey')
    apiKey.addMethod('POST', new LambdaIntegration(apiKeyGeneratorFunction), {
      authorizationType: AuthorizationType.IAM,
    })

    const ruleInstances = api.root.addResource('rule-instance')
    ruleInstances.addMethod(
      'POST',
      new LambdaIntegration(ruleInstanceFunction),
      {
        authorizationType: AuthorizationType.IAM,
      }
    )
    const ruleInstance = ruleInstances.addResource('{id}')
    ruleInstance.addMethod('PUT', new LambdaIntegration(ruleInstanceFunction), {
      authorizationType: AuthorizationType.IAM,
    })
    ruleInstance.addMethod(
      'DELETE',
      new LambdaIntegration(ruleInstanceFunction),
      {
        authorizationType: AuthorizationType.IAM,
      }
    )

    /**
     * IAM roles
     */
    const apiKeyAuthorizerBaseRole = new Role(
      this,
      'ApiKeyAuthorizerBaseRole',
      {
        // TODO: Make the role name shared with lambda
        roleName: 'ApiKeyAuthorizerBaseRole',
        assumedBy: new ArnPrincipal(
          apiKeyAuthorizerFunction.role?.roleArn as string
        ),
        managedPolicies: [
          ManagedPolicy.fromAwsManagedPolicyName('PowerUserAccess'),
        ],
      }
    )
    apiKeyAuthorizerFunction.role?.attachInlinePolicy(
      new Policy(this, 'ApiKeyAuthorizerPolicy', {
        statements: [
          new PolicyStatement({
            effect: Effect.ALLOW,
            actions: ['sts:AssumeRole'],
            resources: [apiKeyAuthorizerBaseRole.roleArn],
          }),
        ],
      })
    )

    /**
     * Outputs
     */
    new CfnOutput(
      this,
      'API Gateway endpoint URL for Prod stage for Rules Engine function',
      {
        value: api.urlForPath('/'),
      }
    )
    new CfnOutput(this, 'Post Rules Engine Function Name', {
      value: verifyTransactionFunction.functionName,
    })

    new CfnOutput(this, 'Transaction Table', {
      value: dynamoDbTable.tableName,
    })
  }
}

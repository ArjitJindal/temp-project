import { Config } from '@cdk/configs/config'
import { StackConstants, getResourceName } from '@cdk/constants'
import { Fn, RemovalPolicy } from 'aws-cdk-lib'
import {
  ApiDefinition,
  AssetApiDefinition,
  EndpointType,
  LogGroupLogDestination,
  MethodLoggingLevel,
  ResponseType,
  SpecRestApi,
} from 'aws-cdk-lib/aws-apigateway'
import { LogGroup } from 'aws-cdk-lib/aws-logs'
import { Asset } from 'aws-cdk-lib/aws-s3-assets'
import { Construct } from 'constructs'
import _ from 'lodash'

const isDevUserStack = process.env.ENV === 'dev:user'

export function createApiGateway(
  context: Construct & { config: Config },
  apiName: string
): {
  api: SpecRestApi
  logGroup: LogGroup
} {
  // Log group ID cannot be changed
  let logGroupId: string
  let openapiName:
    | 'public'
    | 'public-management'
    | 'public-device-data'
    | 'public-sanctions'
    | 'internal'
  if (apiName === StackConstants.TARPON_API_NAME) {
    openapiName = 'public'
    logGroupId = 'LogGroupPublicApi'
  } else if (apiName === StackConstants.TARPON_MANAGEMENT_API_NAME) {
    openapiName = 'public-management'
    logGroupId = 'LogGroupPublicManagementApi'
  } else if (apiName === StackConstants.TARPON_DEVICE_DATA_API_NAME) {
    openapiName = 'public-device-data'
    logGroupId = 'LogGroupPublicDeviceDataApi'
  } else if (apiName === StackConstants.TARPON_SANCTIONS_API_NAME) {
    openapiName = 'public-sanctions'
    logGroupId = 'LogGroupPublicSanctionsApi'
  } else if (apiName === StackConstants.CONSOLE_API_NAME) {
    openapiName = 'internal'

    // TODO: Remove this in the next PR
    apiName += 'New'
    logGroupId = 'LogGroupConsoleApiNew'
  } else {
    throw new Error(`Cannot find openapi for ${apiName}`)
  }

  const OPENAPI_PATH = `./dist/openapi/openapi-${openapiName}-autogenerated-${context.config.stage}.yaml`
  let apiDefinition: ApiDefinition
  if (context.config.stage === 'local') {
    apiDefinition = ApiDefinition.fromAsset(OPENAPI_PATH)
  } else {
    const openApiAsset = new Asset(context, `${openapiName}-openapi-asset`, {
      path: OPENAPI_PATH,
    })
    const openApiData = Fn.transform('AWS::Include', {
      Location: openApiAsset.s3ObjectUrl,
    })
    apiDefinition = AssetApiDefinition.fromInline(openApiData)
  }
  const logGroupName = getResourceName(`API-Gateway-Execution-Logs_${apiName}`)
  const apiLogGroup = new LogGroup(context, logGroupId, {
    logGroupName,
    removalPolicy:
      context.config.stage === 'dev'
        ? RemovalPolicy.DESTROY
        : RemovalPolicy.RETAIN,
  })

  const restApi = new SpecRestApi(context, apiName, {
    endpointTypes: isDevUserStack
      ? [EndpointType.REGIONAL]
      : [EndpointType.EDGE],
    restApiName: apiName,
    apiDefinition,
    deploy: true,
    deployOptions: {
      loggingLevel: MethodLoggingLevel.INFO,
      tracingEnabled: true,
      accessLogDestination: new LogGroupLogDestination(apiLogGroup),
    },
  })

  // NOTE: We add random spaces to the end of the validation response template (which won't affect the response) to make
  // the template get updated for every deployment (0.1% chance of conflict) to get around the template being reset for
  // unknown reasons.
  const randomSpacesSuffix = _.range(_.random(1, 1000))
    .map(() => '')
    .join(' ')
  const apiValidationErrorTemplate = {
    'application/json':
      '{ "message": $context.error.messageString, "validationErrors": "$context.error.validationErrorString" }' +
      randomSpacesSuffix,
  }
  restApi.addGatewayResponse('BadRequestBodyValidationResponse', {
    type: ResponseType.BAD_REQUEST_BODY,
    statusCode: '400',
    templates: apiValidationErrorTemplate,
  })
  restApi.addGatewayResponse('BadRequestParametersValidationResponse', {
    type: ResponseType.BAD_REQUEST_PARAMETERS,
    statusCode: '400',
    templates: apiValidationErrorTemplate,
  })
  return {
    api: restApi,
    logGroup: apiLogGroup,
  }
}

/* eslint-disable @typescript-eslint/no-explicit-any */

/**
 * This script injects AWS API Gateway specific settings into our internal openapi and output to lib/openapi-internal-autogenerated.yaml
 */

import * as fs from 'fs'
import * as yaml from 'js-yaml'
import _ from 'lodash'
import { HammerheadStackConstants, TarponStackConstants } from '../constants'

const PathToLambda: any = {
  '/tenants': TarponStackConstants.TENANT_FUNCTION_NAME,
  '/tenants/settings': TarponStackConstants.TENANT_FUNCTION_NAME,
  '/accounts': TarponStackConstants.ACCOUNT_FUNCTION_NAME,
  '/accounts/{userId}/change_tenant':
    TarponStackConstants.ACCOUNT_FUNCTION_NAME,
  '/accounts/{userId}': TarponStackConstants.ACCOUNT_FUNCTION_NAME,
  '/apikey': TarponStackConstants.API_KEY_GENERATOR_FUNCTION_NAME,
  '/rule_implementations': TarponStackConstants.RULE_FUNCTION_NAME,
  '/iam/rules': TarponStackConstants.RULE_FUNCTION_NAME,
  '/rules': TarponStackConstants.RULE_FUNCTION_NAME,
  '/rules/{ruleId}': TarponStackConstants.RULE_FUNCTION_NAME,
  '/iam/rule_instances': TarponStackConstants.RULE_INSTANCE_FUNCTION_NAME,
  '/rule_instances': TarponStackConstants.RULE_INSTANCE_FUNCTION_NAME,
  '/rule_instances/{ruleInstanceId}':
    TarponStackConstants.RULE_INSTANCE_FUNCTION_NAME,
  '/import': TarponStackConstants.FILE_IMPORT_FUNCTION_NAME,
  '/import/{importId}': TarponStackConstants.FILE_IMPORT_FUNCTION_NAME,
  '/files/getPresignedUrl':
    TarponStackConstants.GET_PRESIGNED_URL_FUNCTION_NAME,
  '/lists': TarponStackConstants.LIST_IMPORTER_FUNCTION_NAME,
  '/transactions': TarponStackConstants.TRANSACTIONS_VIEW_FUNCTION_NAME,
  '/transactions/export': TarponStackConstants.TRANSACTIONS_VIEW_FUNCTION_NAME,
  '/transactions/{transactionId}':
    TarponStackConstants.TRANSACTIONS_VIEW_FUNCTION_NAME,
  '/consumer/users': TarponStackConstants.CONSUMER_USERS_VIEW_FUNCTION_NAME,
  '/consumer/users/{userId}':
    TarponStackConstants.CONSUMER_USERS_VIEW_FUNCTION_NAME,
  '/consumer/users/{userId}/files':
    TarponStackConstants.CONSUMER_USERS_VIEW_FUNCTION_NAME,
  '/consumer/users/{userId}/files/{fileId}':
    TarponStackConstants.CONSUMER_USERS_VIEW_FUNCTION_NAME,
  '/business/users': TarponStackConstants.BUSINESS_USERS_VIEW_FUNCTION_NAME,
  '/business/users/{userId}':
    TarponStackConstants.BUSINESS_USERS_VIEW_FUNCTION_NAME,
  '/business/users/{userId}/files':
    TarponStackConstants.BUSINESS_USERS_VIEW_FUNCTION_NAME,
  '/business/users/{userId}/files/{fileId}':
    TarponStackConstants.BUSINESS_USERS_VIEW_FUNCTION_NAME,
  '/dashboard_stats/transactions':
    TarponStackConstants.DASHBOARD_STATS_TRANSACTIONS_FUNCTION_NAME,
  '/dashboard_stats/hits_per_user':
    TarponStackConstants.DASHBOARD_STATS_TRANSACTIONS_FUNCTION_NAME,
  '/transactions/{transactionId}/comments':
    TarponStackConstants.TRANSACTIONS_VIEW_FUNCTION_NAME,
  '/transactions/{transactionId}/comments/{commentId}':
    TarponStackConstants.TRANSACTIONS_VIEW_FUNCTION_NAME,
  '/dashboard_stats/rule_hit':
    TarponStackConstants.TRANSACTIONS_VIEW_FUNCTION_NAME,
  '/pulse/risk-classification':
    HammerheadStackConstants.RISK_CLASSIFICATION_FUNCTION_NAME,
  '/pulse/manual-risk-assignment':
    HammerheadStackConstants.MANUAL_USER_RISK_ASSIGNMENT_FUNCTION_NAME,
  '/pulse/risk-parameter':
    HammerheadStackConstants.PARAMETER_RISK_ASSIGNMENT_FUNCTION_NAME,
}

function assertValidLambdaMappings(openapi: any) {
  const pathsLocal = Object.keys(PathToLambda)
  const pathsRemote = Object.keys(openapi.paths)
  if (
    pathsLocal.length !== pathsRemote.length ||
    new Set([...pathsLocal, ...pathsRemote]).size !== pathsRemote.length
  ) {
    throw new Error(
      `
      Paths in PathToLambda are not in sync with remote internal openapi paths. Please update PathToLambda

      Local paths: ${pathsLocal}

      Remote paths: ${pathsRemote}


      Diff: ${pathsLocal
        .filter((path) => !pathsRemote.includes(path))
        .concat(pathsRemote.filter((path) => !pathsLocal.includes(path)))}\n`
    )
  }
}

const openapi = yaml.load(
  fs.readFileSync('./lib/openapi/openapi-internal-original.yaml', 'utf8')
) as any

assertValidLambdaMappings(openapi)

// Filter out not-yet-implemented paths
openapi.paths = _.omit(
  openapi.paths,
  Object.keys(PathToLambda).filter((path) => !PathToLambda[path])
)

// Request validator setting
openapi['x-amazon-apigateway-request-validators'] = {
  all: {
    validateRequestBody: true,
    validateRequestParameters: true,
  },
}

// IAM authorization setting
openapi['components']['securitySchemes']['sigv4'] = {
  type: 'apiKey',
  name: 'Authorization',
  in: 'header',
  'x-amazon-apigateway-authtype': 'awsSigv4',
}

// Labmda authorizer setting
openapi['components']['securitySchemes']['lambda-authorizer'] = {
  type: 'apiKey',
  name: 'Authorization',
  in: 'header',
  'x-amazon-apigateway-authorizer': {
    type: 'request',
    identitySource: 'method.request.header.authorization',
    authorizerUri: {
      'Fn::Sub': `arn:aws:apigateway:\${AWS::Region}:lambda:path/2015-03-31/functions/\${${TarponStackConstants.JWT_AUTHORIZER_FUNCTION_NAME}.Arn}/invocations`,
    },
    authorizerResultTtlInSeconds: 600,
    enableSimpleResponses: false,
  },
  'x-amazon-apigateway-authtype': 'Custom scheme with tenant claims',
}

// Labmda integrations
for (const path in openapi.paths) {
  for (const method in openapi.paths[path]) {
    const methodSetting = openapi.paths[path][method]
    const lambdaFunctionName = PathToLambda[path]

    methodSetting['x-amazon-apigateway-request-validator'] = 'all'
    methodSetting['x-amazon-apigateway-integration'] = {
      uri: {
        'Fn::Sub': `arn:aws:apigateway:$\{AWS::Region}:lambda:path/2015-03-31/functions/$\{${lambdaFunctionName}.Arn}/invocations`,
      },
      httpMethod: 'POST',
      type: 'aws_proxy',
      passthroughBehavior: 'never',
    }

    // TODO: Remove IAM auth after we can configure these in the FDT console
    if (['/apikey', '/iam/rules', '/iam/rule_instances'].includes(path)) {
      methodSetting['x-amazon-apigateway-auth'] = { type: 'AWS_IAM' }
      methodSetting['security'] = [{ sigv4: [] }]
    } else {
      methodSetting['security'] = [{ 'lambda-authorizer': [] }]
    }
  }

  // CORS handling (because we use SpecRestApi, so we need to create OPTIONS method for all child resources by ourselves)
  openapi.paths[path]['options'] = {
    parameters: [],
    responses: {
      '200': {
        description: 'Default response',
        headers: {
          'Access-Control-Allow-Headers': {
            schema: {
              type: 'string',
            },
          },
          'Access-Control-Allow-Methods': {
            schema: {
              type: 'string',
            },
          },
          'Access-Control-Allow-Origin': {
            schema: {
              type: 'string',
            },
          },
        },
      },
    },
    'x-amazon-apigateway-integration': {
      type: 'mock',
      requestTemplates: {
        'application/json': '{"statusCode":200}',
      },
      responses: {
        default: {
          statusCode: 200,
          responseParameters: {
            'method.response.header.Access-Control-Allow-Headers': "'*'",
            'method.response.header.Access-Control-Allow-Methods': "'*'",
            'method.response.header.Access-Control-Allow-Origin':
              process.env.ENV === 'dev'
                ? "'*'"
                : process.env.ENV === 'sandbox'
                ? "'https://sandbox.console.flagright.com'"
                : "'https://console.flagright.com'",
          },
        },
      },
    },
  }
}

// Inject public API schemas and replace external URL with relative path
// because exporting 'Bundled References' in stoplight doesn't deference recursively
// and openapi-generator doesn't build for the 'Bundled References' version.
// TODO: This workaround should be removed after stoplight fixes this issue.
const publicOpenapi = yaml.load(
  fs.readFileSync('./lib/openapi/openapi-public-original.yaml', 'utf8')
) as any
openapi['components']['schemas'] = {
  ...openapi['components']['schemas'],
  ...publicOpenapi['components']['schemas'],
}
const autogeneratedYaml = yaml
  .dump(openapi)
  .replace(
    /(>-\n\s+)*https:\/\/stoplight.io\/api.*(\/components\/schemas\/.*)/g,
    "'#$2'"
  )

fs.writeFileSync(
  './lib/openapi/openapi-internal-autogenerated.yaml',
  autogeneratedYaml
)
